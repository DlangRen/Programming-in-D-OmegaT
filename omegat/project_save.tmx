<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="OmegaT-3.5.4" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>$(C !is) is the opposite of $(C is).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T014827Z" creationid="Hipter" creationdate="20160707T014827Z">
        <seg>$(C !is) 与 $(C is) 相反。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C .get()) is useful in such cases: it returns the value associated with the specified key if that key exists, otherwise it returns the default value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T042443Z" creationid="Hipter" creationdate="20160709T042443Z">
        <seg>$(C .get()) 在这样的样例中是有用的：如果指定键存在则返回相应值，否则返回默认值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C .idup) is used for producing immutable strings from existing strings:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T033023Z" creationid="Hipter" creationdate="20160713T033023Z">
        <seg>$(C .idup) 可用来从存在字符串产生不可变的字符串：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C readf()) continues to wait for more characters to add to the string:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T004429Z" creationid="Hipter" creationdate="20160712T004229Z">
        <seg>$(C readf()) 继续等待新输入的字符添加到字符串：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C variable1) and $(C variable2) above merely provide access to that anonymous object:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T011741Z" creationid="Hipter" creationdate="20160706T011741Z">
        <seg>上面的 $(C variable1) 和 $(C variable2) 只提供对那个匿名对象的访问：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(COZUM_BOLUMU Associative Arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T101504Z" creationid="Hipter" creationdate="20160709T095142Z">
        <seg>$(COZUM_BOLUMU 关联数组)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(COZUM_BOLUMU Strings)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="ADR" changedate="20160714T092548Z" creationid="ADR" creationdate="20160714T092548Z">
        <seg>$(COZUM_BOLUMU 字符串)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU $(IX associative array) $(IX AA) Associative Arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T085529Z" creationid="Hipter" creationdate="20160708T082836Z">
        <seg>$(DERS_BOLUMU $(IX 关联数组) $(IX AA) 关联数组)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU $(IX class) Classes)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160701T014126Z" creationid="Hipter" creationdate="20160701T014126Z">
        <seg>$(DERS_BOLUMU $(IX class) 类)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX &amp;quot;) Double quotes, not single quotes)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T075419Z" creationid="Hipter" creationdate="20160712T075419Z">
        <seg>$(H5 $(IX &amp;quot;) 双引号，非单引号)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX formattedRead) $(C formattedRead) for parsing strings)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T030529Z" creationid="Hipter" creationdate="20160712T022848Z">
        <seg>$(H5 $(IX formattedRead) $(C formattedRead) 函数可以解析字符串)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX in, associative array) Determining the presence of a key)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T034942Z" creationid="Hipter" creationdate="20160709T034906Z">
        <seg>$(H5 $(IX in, 关联数组) 确定键的存在)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX readln) $(IX strip) $(C readln) and $(C strip), instead of $(C readf))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T092224Z" creationid="Hipter" creationdate="20160711T092224Z">
        <seg>$(H5 $(IX readln) $(IX strip) $(C readln) 和 $(C strip)，代替 $(C readf))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX remove) Removing key-value pairs)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160709T032109Z">
        <seg>$(H5 $(IX remove) 移除键值对)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX string) $(IX wstring) $(IX dstring) $(IX char[]) $(IX wchar[]) $(IX dchar[]) $(IX immutable) $(C string), $(C wstring), and $(C dstring) are immutable)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T080445Z" creationid="Hipter" creationdate="20160712T080114Z">
        <seg>$(H5 $(IX string) $(IX wstring) $(IX dstring) $(IX char[]) $(IX wchar[]) $(IX dchar[]) $(IX immutable) $(C string)，$(C wstring)，和 $(C dstring) 是不可变的)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Adding key-value pairs)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160708T144521Z">
        <seg>$(H5 添加键值对)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Definition)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T094803Z" creationid="Hipter" creationdate="20160708T094803Z">
        <seg>$(H5 定义)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Example)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T083417Z" creationid="Hipter" creationdate="20160709T083417Z">
        <seg>$(H5 样例)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Initialization)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T030542Z" creationid="Hipter" creationdate="20160709T030542Z">
        <seg>$(H5 初始化)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Properties)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T132650Z" creationid="Hipter" creationdate="20160709T042827Z">
        <seg>$(H5 Properties（属性）)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Summary)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015616Z" creationid="Hipter" creationdate="20160707T015616Z">
        <seg>$(H5 摘要)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX assignment, class) Assignment)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T024616Z" creationid="Hipter" creationdate="20160706T024616Z">
        <seg>$(H6 $(IX assignment, class) 赋值)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX copy, class) Copying)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T011913Z" creationid="Hipter" creationdate="20160706T011913Z">
        <seg>$(H6 $(IX copy, class) 复制)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX is, operator) $(IX !is) The $(C is) and $(C !is) operators)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T013714Z" creationid="Hipter" creationdate="20160707T013714Z">
        <seg>$(H6 $(IX is, 运算符) $(IX !is)   $(C is) 和 $(C !is) 运算符)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Construction)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T033741Z" creationid="Hipter" creationdate="20160706T032028Z">
        <seg>$(H6 构造函数)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Definition)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T031821Z" creationid="Hipter" creationdate="20160706T031821Z">
        <seg>$(H6 定义)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Destruction)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T033752Z" creationid="Hipter" creationdate="20160706T033700Z">
        <seg>$(H6 析构函数)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Member functions)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T005242Z" creationid="Hipter" creationdate="20160707T005242Z">
        <seg>$(H6 成员函数)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Operator overloading)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T004731Z" creationid="Hipter" creationdate="20160707T004731Z">
        <seg>$(H6 运算符重载)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(HILITE final) int func() {    $(CODE_NOTE Recommended)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T012540Z" creationid="Hipter" creationdate="20160707T012540Z">
        <seg>$(HILITE final) int func() {    $(CODE_NOTE 推荐)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(I ($(B Note:) This is related to name scopes, as well as object lifetimes, which will be explained in $(LINK2 /ders/d.en/lifetimes.html, a later chapter.)))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T025009Z" creationid="Hipter" creationdate="20160707T022842Z">
        <seg>$(I ($(B 注：) 这与命名作用域，以及对象生存期有关，这将在 $(LINK2 /ders/d.cn/lifetimes.html, 后面的章节) 中解释。))
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(I value_type)[$(I key_type)] $(I associative_array_name);
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T095157Z" creationid="Hipter" creationdate="20160708T095114Z">
        <seg>$(I 值类型)[$(I 键类型)] $(I 关联数组名);
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
Although some of the functions in Phobos modules will be easy to use with strings, library documentations are usually terse compared to tutorials.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T093624Z" creationid="大处着手小处着眼" creationdate="20160714T093404Z">
        <seg>$(LI
对于字符串，虽然 Phobos 模块的一些函数易于使用，但库文档通常比教程简洁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
Another solution is to assign an empty array:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T115803Z" creationid="Hipter" creationdate="20160711T012526Z">
        <seg>$(LI
另一种解法是用空数组赋值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
Many other functions may be chained as well:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T095132Z" creationid="大处着手小处着眼" creationdate="20160714T095132Z">
        <seg>$(LI
许多别的函数可以嵌套使用Many other functions may be chained as well:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
Since the initial value of an array is an empty array anyway, the following technique would achieve the same result:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T013753Z" creationid="Hipter" creationdate="20160711T013753Z">
        <seg>$(LI
由于数组的初始值无论如何都是一个空数组，那么下面的技术将得到一样的结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
The $(C .keys) property returns a slice (i.e. dynamic array) that includes all of the keys of the associative array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T115704Z" creationid="Hipter" creationdate="20160709T101654Z">
        <seg>$(LI
$(C .keys) property（属性）返回一个切片(即 动态数组)，它包含了关联数组全部的键。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
The goal is to store multiple grades per student.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T013837Z" creationid="Hipter" creationdate="20160711T013837Z">
        <seg>$(LI
目标是存储每个学生的多个成绩。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI  类是引用类型。The $(C new) 关键字构造一个匿名 $(I class 对象) 并返回一个 $(I class 变量)。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T041335Z" creationid="Hipter" creationdate="20160708T041335Z">
        <seg>$(LI  类是引用类型。 $(C new) 关键字构造一个匿名 $(I class 对象) 并返回一个 $(I class 变量)。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C catch) and $(C finally) cannot be used without a $(C try) block.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T022354Z" creationid="Hipter" creationdate="20160707T022354Z">
        <seg>$(LI 没有一个 $(C try) 块， $(C catch) 和 $(C finally) 不能使用。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C scope(failure)): the expression is executed only if the scope is being exited due to an exception)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T051533Z" creationid="Hipter" creationdate="20160707T025720Z">
        <seg>$(LI $(C scope(failure))：表达式只在因出现异常而退出作用域时被执行。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C scope(success)): the expression is executed only if the scope is being exited successfully)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T025415Z" creationid="Hipter" creationdate="20160707T025415Z">
        <seg>$(LI $(C scope(success))：表达式只在成功退出作用域时被执行。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .byKey) $(C .byKey) provides access to the keys without copying them; we will see how $(C .byKey) is used in $(C foreach) loops in the next chapter.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T025532Z" creationid="Hipter" creationdate="20160709T081414Z">
        <seg>$(LI $(IX .byKey) $(C .byKey) 提供对键的直接访问；在下一章我们将看到在 $(C foreach) 循环中如何使用 $(C .byKey) 。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .byKeyValue) $(C .byKeyValue) provides access to the key-value pairs without copying them.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T025550Z" creationid="Hipter" creationdate="20160709T082623Z">
        <seg>$(LI $(IX .byKeyValue) $(C .byKeyValue) 提供对键值对的直接访问。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .byValue) $(C .byValue) provides access to the values without copying them.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T025539Z" creationid="Hipter" creationdate="20160709T082217Z">
        <seg>$(LI $(IX .byValue) $(C .byValue) 提供对值的直接访问。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .clear) $(C .clear) removes all elements.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T083332Z" creationid="Hipter" creationdate="20160709T083332Z">
        <seg>$(LI $(IX .clear) $(C .clear) 移除全部元素。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .get) $(C .get) returns the value if it exists, the default value otherwise.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T133139Z" creationid="Hipter" creationdate="20160709T083159Z">
        <seg>$(LI $(IX .get) $(C .get) 值存在即返回相应值，否则返回默认值。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .keys) $(C .keys) returns a copy of all keys as a dynamic array.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080658Z" creationid="Hipter" creationdate="20160709T080658Z">
        <seg>$(LI $(IX .keys) $(C .keys) 返回全部键的动态数组副本。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .length) $(C .length) returns the number of key-value pairs.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080521Z" creationid="Hipter" creationdate="20160709T080521Z">
        <seg>$(LI $(IX .length) $(C .length) 返回键值对的个数。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .rehash) $(C .rehash) may make the array more efficient in some cases, such as after inserting a large number of key-value pairs.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T082830Z" creationid="Hipter" creationdate="20160709T082830Z">
        <seg>$(LI $(IX .rehash) $(C .rehash) 在一些例子中可以让数组更有效率，比如在插入大量的键值对之后。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .remove) $(C .remove) removes the specified key and its value from the array.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T083314Z" creationid="Hipter" creationdate="20160709T083314Z">
        <seg>$(LI $(IX .remove) $(C .remove) 从数组中移除指定的键和值。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .sizeof, associative array) $(C .sizeof) is the size of the array $(I reference) (it has nothing to do with the number of key-value pairs in the table and is the same value for all associative arrays).)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T045628Z" creationid="Hipter" creationdate="20160709T083105Z">
        <seg>$(LI $(IX .sizeof, associative array) $(C .sizeof) 数组$(I 引用)大小（它不受表中键值对个数的影响，对所有的关联数组来说值都是一样的）。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .values) $(C .values) returns a copy of all values as a dynamic array.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T081449Z" creationid="Hipter" creationdate="20160709T081449Z">
        <seg>$(LI $(IX .values) $(C .values) 返回全部值的动态数组副本。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Assigning an empty associative array.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T084451Z" creationid="Hipter" creationdate="20160709T084139Z">
        <seg>$(LI 用一个空的关联数组赋值。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Assignment associates a variable with an object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020548Z" creationid="Hipter" creationdate="20160707T020548Z">
        <seg>$(LI 赋值会把一个变量与一个对象相关联。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Class variables that are not associated with any object are $(C null).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020015Z" creationid="Hipter" creationdate="20160707T020015Z">
        <seg>$(LI 不与任何对象相关联的类变量为 $(C null)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Classes and structs share common features but have big differences.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015731Z" creationid="Hipter" creationdate="20160707T015731Z">
        <seg>$(LI 类和结构虽然有共同特点，但还是有很大的差异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Classes are reference types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015816Z" creationid="Hipter" creationdate="20160707T015816Z">
        <seg>$(LI  类是引用类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Removing them one-by-one from the associative array.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T084106Z" creationid="Hipter" creationdate="20160709T084106Z">
        <seg>$(LI 从关联数组中逐个移除它们。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Similar to the previous method, assigning the array's $(C .init) property.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T084440Z" creationid="Hipter" creationdate="20160709T084440Z">
        <seg>$(LI 与前一方法相似，用数组的 $(C .init) 属性赋值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Some of the variables that these blocks need may not be accessible within these blocks:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T022405Z" creationid="Hipter" creationdate="20160707T022405Z">
        <seg>$(LI 属于块的某些变量，块范围内有可能访问不到：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI The act of copying associates an additional variable with an object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020218Z" creationid="Hipter" creationdate="20160707T020218Z">
        <seg>$(LI 复制操作将增加一个与对象关联的变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI This program uses two indexes to make a slice:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T095454Z" creationid="大处着手小处着眼" creationdate="20160714T095340Z">
        <seg>$(LI 这段程序使用两个索引值来生成一个切片：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Writing all of potentially unrelated expressions in the single $(C finally) block at the bottom separates those expressions from the actual code that they are related to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T024639Z" creationid="Hipter" creationdate="20160707T024639Z">
        <seg>$(LI 把所有可能无关联的表达式写在底部单独的 $(C finally) 块，就可以分离那些有关联的可执行代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI 一个类的析构函数不得访问由垃圾回收器管理的成员。这是因为垃圾回收器没有必要保证该对象及其成员按任何特定顺序终结。当析构函数执行时，全部成员应该已经终结。)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T060951Z" creationid="Hipter" creationdate="20160708T060116Z">
        <seg>$(LI 一个类的析构函数不得访问由垃圾回收器管理的成员。这是因为垃圾回收器没有被要求保证该对象及其成员按任何特定顺序终结。当析构函数执行时，全部成员应该已经终结。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI 类的析构函数不必分配新的内存给垃圾回收器。这是因为垃圾回收器没有必要保证在垃圾回收周期内能分配新的对象。)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T060943Z" creationid="Hipter" creationdate="20160708T055701Z">
        <seg>$(LI 类的析构函数一定不分配由垃圾回收器管理的新内存。这是因为垃圾回收器没有被要求保证在垃圾回收周期内能分配新的对象。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(OL
$(LI The type of string literals like $(STRING "hello") is $(C string), not $(C char[]), so they are immutable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T024251Z" creationid="Hipter" creationdate="20160713T024251Z">
        <seg>$(OL
$(LI 像 $(STRING "hello") 这样的字符串字面量的类型是 $(C string)，而不是 $(C char[])，因此它们不可变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C .clear) removes all elements:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T034400Z" creationid="Hipter" creationdate="20160709T034400Z">
        <seg>$(P
$(C .clear) 移除全部元素：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C is) specifies whether two class variables provide access to the same class object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T014640Z" creationid="Hipter" creationdate="20160707T014640Z">
        <seg>$(P
$(C is) 确定两个类变量是否提供对同一对象的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C readln()) can be used without a parameter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T021213Z" creationid="Hipter" creationdate="20160712T021213Z">
        <seg>$(P
$(C readln()) 没有参数也可以使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C readln()) is more suitable when reading strings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T015132Z" creationid="Hipter" creationdate="20160712T015132Z">
        <seg>$(P
$(C readln()) 更适合读取字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C readln()) stores the new-line character as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T015736Z" creationid="Hipter" creationdate="20160712T015736Z">
        <seg>$(P
$(C readln()) 也存储新行符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C scope) statements can be specified as blocks as well:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T035056Z" creationid="Hipter" creationdate="20160707T035056Z">
        <seg>$(P
$(C scope) 语句也可以像块一样使用：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B Note:) An associative array that is defined without any element is $(LINK2 /ders/d.en/null_is.html, $(C null)), not empty.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T143323Z" creationid="Hipter" creationdate="20160708T081001Z">
        <seg>$(P
$(I $(B 注：) 已定义的没有任何元素的关联数组是 $(LINK2 /ders/d.cn/null_is.html, $(C null))，而不是空。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B Note:) It is usually not proper to access members directly as in the code above.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T023005Z" creationid="Hipter" creationdate="20160707T004627Z">
        <seg>$(P
$(I $(B 注：) 在上面的代码中，一般不这样直接访问成员。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B 注：) 在上面的代码中，一般不这样直接访问成员。若确实需要这样的语法，应该首选属性，这将在 $(LINK2 /ders/d.cn/property.html, 后面的章节) 中解释。)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T020523Z" creationid="Hipter" creationdate="20160708T020523Z">
        <seg>$(P
$(I $(B 注：) 在上面的代码中，一般不这样直接访问成员。若确实需要这样的语法，应该首选属性，这将在 $(LINK2 /ders/d.cn/property.html, 后面的一章) 中解释。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX .init, clearing a variable) $(I $(B Note:) The $(C .init) property of any variable or type is the initial value of that type:)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T084743Z" creationid="Hipter" creationdate="20160709T084655Z">
        <seg>$(P
$(IX .init, 清除一个变量) $(I $(B 注：) 任何变量或类型的 $(C .init) 属性是类型的初始值：)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX :, associative array) Sometimes some of the mappings between the keys and the values are already known at the time of the definition of the associative array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T030702Z" creationid="Hipter" creationdate="20160709T030702Z">
        <seg>$(P
$(IX :, 关联数组) 有时候一些键与值的映射在定义关联数组的时候就已经明确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX OOP) $(IX 面向对象编程) 与结构相似， $(C class) 具有定义新类型的功能。不同于结构的是，在D中，类提供 $(I 面向对象编程) (OOP) 模型。下面是OOP的主要方面：
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T015721Z" creationid="Hipter" creationdate="20160708T015721Z">
        <seg>$(P
$(IX OOP) $(IX 面向对象编程) 与结构相似， $(C class) 具有定义新类型的功能。不同于结构的是，在D语言中，类提供 $(I 面向对象编程) (OOP) 模型。下面是OOP的主要方面：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX final) As overridable member functions have a runtime performance cost, without going into more detail, I recommend that you define all $(C class) functions that do not need to be overridden with the $(C final) keyword.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T012042Z" creationid="Hipter" creationdate="20160707T012042Z">
        <seg>$(P
$(IX final) 由于可重写的成员函数有一个运行时性能消耗，在这儿不讨论更多细节，我推荐您定义全部没必要用 $(C final) 关键字重写的 $(C class) 成员函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX 终结与析构) 然而，不同于结构，在一个类对象的生命期结束时，类的析构函数并不执行。正如上面我们看到的，析构函数在一个垃圾回收周期内的未来某个时候执行。(通过这样的区分，更准确的说，类析构函数应该叫 $(I 终结函数)) 。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T151443Z" creationid="Hipter" creationdate="20160707T050655Z">
        <seg>$(P
$(IX 终结与析构) 然而，不同于结构，在一个类对象的生命期结束时，类的析构函数并不执行。正如上面我们看到的，析构函数在一个垃圾回收周期内的未来某个时候执行。(通过这样的区分，更准确的说，类的析构函数应该叫 $(I 终结函数)) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Although member functions are defined and used the same way as structs, there is an important difference: Class member functions can be and by-default are $(I overridable).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T005644Z" creationid="Hipter" creationdate="20160707T005311Z">
        <seg>$(P
虽然成员函数的定义与用法与结构相同，有个重要的不同：类成员函数默认是 $(I 可重写的) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Although the syntax makes it look as if a member of the $(I variable) is being accessed, it is actually the member of the $(I object).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T004236Z" creationid="Hipter" creationdate="20160707T004236Z">
        <seg>$(P
虽然语法上看起来像访问 $(I 变量) 的成员，实际上是 $(I 对象) 的成员。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Although these statements are closely related to exceptions, they can be used without a $(C try-catch) block.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T025855Z" creationid="Hipter" creationdate="20160707T025855Z">
        <seg>$(P
虽然这些语句只在特殊情况下使用，但是没有 $(C try-catch) 块也能用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Another difference from structs is that some member functions are automatically inherited from the $(C Object) class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T012709Z" creationid="Hipter" creationdate="20160707T012709Z">
        <seg>$(P
与结构不同的是一些成员函数自动继承自 $(C Object) 类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As a result, the objects that are associated with $(C var1) and $(C var2) are different.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T023913Z" creationid="Hipter" creationdate="20160706T023913Z">
        <seg>$(P
结果是，$(C var1) 和 $(C var2) 相关联的对象是不同的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As an example, let's write the function above with a $(C scope(failure)) statement:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T030221Z" creationid="Hipter" creationdate="20160707T030221Z">
        <seg>$(P
例如，让我们用 $(C scope(failure)) 语句写一下面的函数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As seen in the outputs, the blocks of the $(C scope) statements are executed in reverse order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T045137Z" creationid="Hipter" creationdate="20160707T035844Z">
        <seg>$(P
在输出中我们看到，$(C scope) 语句块是按相反的顺序执行的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As we have seen in the previous chapter, expressions that must always be executed are written in the $(C finally) block, and expressions that must be executed when there are error conditions are written in $(C catch) blocks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T021804Z" creationid="Hipter" creationdate="20160707T021608Z">
        <seg>$(P
在前面的章节我们已经看到，写在 $(C finally) 块里的表达式一定总被执行。当有错误条件的时候，写在 $(C catch) 块里的表达式总被执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As with structs, the name of the constructor is $(C this).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T032221Z" creationid="Hipter" creationdate="20160706T032221Z">
        <seg>$(P
与结构一样，构造函数的名称是 $(C this) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As with structs, the name of the destructor is $(C ~this):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T033855Z" creationid="Hipter" creationdate="20160706T033855Z">
        <seg>$(P
像结构一样，析构函数的名称是 $(C ~this):
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Assigning to a class variable disassociates that variable from its current object and associates it with a new object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T030537Z" creationid="Hipter" creationdate="20160706T030537Z">
        <seg>$(P
给类变量赋值，会解除变量与当前对象的关联，并关联到一个新对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Associative arrays allow indexing not only using integers but also using any other type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T085816Z" creationid="Hipter" creationdate="20160708T085816Z">
        <seg>$(P
关联数组允许索引不只是整型而是任何类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Associative arrays are a feature that is found in most modern high-level languages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092745Z" creationid="Hipter" creationdate="20160708T014736Z">
        <seg>$(P
关联数组是大多数现代高级编程语言所具有的功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Associative arrays are implemented in D using a $(I hash table).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T023247Z" creationid="Hipter" creationdate="20160708T091112Z">
        <seg>$(P
在D语言中，关联数组是一个 $(I hash 表) 实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Associative arrays make it easy to access the grades by the name of the student as in $(C grades["emre"]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T030054Z" creationid="Hipter" creationdate="20160709T092116Z">
        <seg>$(P
在 $(C grades["emre"]) 中通过学生姓名关联数组让它很容易访问到成绩。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Assume that an associative array is used for storing student grades.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T085200Z" creationid="Hipter" creationdate="20160709T085200Z">
        <seg>$(P
假设使用关联数组来存储学生成绩。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Because classes are reference types, defining a new class variable as a copy of another makes two variables that provide access to the same object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T012453Z" creationid="Hipter" creationdate="20160706T012143Z">
        <seg>$(P
因为类是引用类型，定义一个新的类变量做为另一个副本，将产生两个访问同一对象的变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Being character arrays, strings can contain control characters like $(STRING '\n') as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T092733Z" creationid="Hipter" creationdate="20160711T092733Z">
        <seg>$(P
作为字符数组，字符串能包含像 $(STRING '\n') 这样的控制字符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Both $(C readf()) and $(C formattedRead()) $(I return) the number of items that they could parse and convert successfully.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T072948Z" creationid="Hipter" creationdate="20160712T035510Z">
        <seg>$(P
$(C readf()) 和 $(C formattedRead()) 函数 都可以成功$(I 返回)解析及转换的项目个数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Both of the variables above provide access to the same object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015547Z" creationid="Hipter" creationdate="20160707T015547Z">
        <seg>$(P
上面的两个变量都提供对同一对象的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Classes are defined by the $(C class) keyword instead of the $(C struct) keyword:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T032013Z" creationid="Hipter" creationdate="20160706T032013Z">
        <seg>$(P
类由 $(C class) 关键字定义而不是 $(C struct) 关键字：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Copying affects only the variables, not the object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T011948Z" creationid="Hipter" creationdate="20160706T011948Z">
        <seg>$(P
复制只影响变量，而不是对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For example, an associative array that maps day names of type $(C string) to day numbers of type $(C int) can be defined like this:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T095549Z" creationid="Hipter" creationdate="20160708T095549Z">
        <seg>$(P
例如，下面这个关联数组这样定义，它把日期名的类型 $(C string) 映射到日期的数字类型 $(C int) ：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For example, the following code that tries to capitalize the first letter of a $(C string) would cause a compilation error:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T021935Z" creationid="Hipter" creationdate="20160712T082540Z">
        <seg>$(P
例如，下面这段代码尝试着修改$(C 字符串)的首字母为大写，将引发一个编译错误： 
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For plain arrays, index values are not stored at all.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T092502Z" creationid="Hipter" creationdate="20160708T092502Z">
        <seg>$(P
对于简单数组，索引值根本就没有存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For that syntax to work, a constructor must be defined explicitly by the programmer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T033504Z" creationid="Hipter" creationdate="20160706T033504Z">
        <seg>$(P
那样的语法要通过编译，就需要程序员显式的定义构造函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Here is a program that prints the Turkish names of colors that are specified in English:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T133329Z" creationid="Hipter" creationdate="20160709T083500Z">
        <seg>$(P
这是一段打印英文颜色的土耳其语表达的程序，它的键指定为英文：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Here is another function that tests all three of these statements:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T035222Z" creationid="Hipter" creationdate="20160707T035222Z">
        <seg>$(P
这儿是另一个函数，来测试全部三个语句：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
How can you solve this problem?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092601Z" creationid="Hipter" creationdate="20160709T092601Z">
        <seg>$(P
怎么解决这个问题？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
I will start using that form after introducing the $(C string) type below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T022215Z" creationid="Hipter" creationdate="20160712T021829Z">
        <seg>$(P
在介绍了下面的 $(C string) 类型之后，我将开始使用格式化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
If an exception is thrown, the output includes the $(C scope(exit)) and $(C scope(failure)) expressions:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T035711Z" creationid="Hipter" creationdate="20160707T035711Z">
        <seg>$(P
如果抛出异常， 输出包括 $(C scope(exit)) 和 $(C scope(failure)) 表达式：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
If no exception is thrown, the output of the function includes only the $(C scope(exit)) and $(C scope(success)) expressions:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T035723Z" creationid="Hipter" creationdate="20160707T035405Z">
        <seg>$(P
如果没有抛出异常， 函数的输出只包括 $(C scope(exit)) 和 $(C scope(success)) 表达式：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
If there is no other class variable that still provides access to the object that has been disassociated from, then that object is going to be destroyed some time in the future by the garbage collector.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T031054Z" creationid="Hipter" creationdate="20160706T031054Z">
        <seg>$(P
如何没有别的类变量能访问已解除关联对象，那该对象将由垃圾回收器在将来某个时候销毁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In the code above, $(C variable2) is being initialized by $(C variable1).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T021450Z" creationid="Hipter" creationdate="20160706T021450Z">
        <seg>$(P
在上面的代码中， $(C variable2) 由 $(C variable1) 初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Just like copying, assignment affects only the variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T024635Z" creationid="Hipter" creationdate="20160706T024635Z">
        <seg>$(P
就像复制，赋值只影响变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Key-value pairs can be removed by using $(C .remove()):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160709T032137Z">
        <seg>$(P
通过 $(C .remove()) 可以移除键值对：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Let's consider the following code that we have seen previously in the $(LINK2 /ders/d.en/value_vs_reference.html, Value Types and Reference Types chapter):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T011152Z" creationid="Hipter" creationdate="20160706T011152Z">
        <seg>$(P
让我们考虑一下下面我们以前在 $(LINK2 /ders/d.cn/value_vs_reference.html, 值类型和引用类型章节) 看到过的代码：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
On the other hand, associative arrays do store both the keys and the values of elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T093619Z" creationid="Hipter" creationdate="20160708T093619Z">
        <seg>$(P
另一方面，关联数组既存储键又存储元素值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Once a line is read from the input or from any other source, it is possible to parse and convert separate data that it may contain with $(C formattedRead()) of the $(C std.format) module.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T031338Z" creationid="Hipter" creationdate="20160712T031338Z">
        <seg>$(P
一但从输入端或别的任何源处读取了一行，$(C std.format) 模块的 $(C formattedRead()) 函数就有可能去解析并转换分割的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
One way of terminating the standard input stream in a terminal is pressing Ctrl-D under Unix-based systems and Ctrl-Z under Windows systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T005431Z" creationid="Hipter" creationdate="20160712T004913Z">
        <seg>$(P
在终端结束标准输入流的方法随系统而不同，在 Unix 系统下按 Ctrl-D，在 Windows 系统下按 Ctrl-Z。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Other than the fact that $(C opAssign) cannot be overloaded for classes, operator overloading is the same as structs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T005026Z" creationid="Hipter" creationdate="20160707T005026Z">
        <seg>$(P
虽然 $(C opAssign) 不能被类重载，但与结构一样，可以实现运算符重载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Same as structs, the members are accessed by the $(I dot) operator:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T004024Z" creationid="Hipter" creationdate="20160707T004024Z">
        <seg>$(P
与结构一样，用 $(I 点) 运算符访问成员：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Similarly, $(C char[]) cannot be used where a $(C string) is needed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T030046Z" creationid="Hipter" creationdate="20160713T030046Z">
        <seg>$(P
同样的，$(C char[]) 不能被用到需要 $(C string) 的地方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Similarly, an $(C immutable) copy of an object can be provided by a member function appropriately named $(C idup()):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T024412Z" creationid="Hipter" creationdate="20160706T024412Z">
        <seg>$(P
同样的，可以由命名为 $(C idup()) 的适当的成员函数提供对象的 $(C immutable) 副本：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since $(C char[]) is mutable and $(C string) is not, there is a mismatch.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T024802Z" creationid="Hipter" creationdate="20160713T024802Z">
        <seg>$(P
由于 $(C char[]) 可变而 $(C string) 不可变，两者不批配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since no object gets copied, the postblit function $(C this(this)) is not available for classes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T013216Z" creationid="Hipter" creationdate="20160706T013139Z">
        <seg>$(P
由于没有复制对象， postblit 函数 $(C this(this)) 不能用于类变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since the array does not contain a value for the key $(STRING "purple"), $(C .get()) returns -1:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T094942Z" creationid="Hipter" creationdate="20160709T042816Z">
        <seg>$(P
由于键 $(STRING "purple") 的值不在数组中，$(C .get()) 返回 -1：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since the objects of $(C myKing) and $(C yourKing) variables are different, the $(C !is) operator returns $(C true).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015100Z" creationid="Hipter" creationdate="20160707T015100Z">
        <seg>$(P
由于 $(C myKing) 和 $(C yourKing) 变量来自不同的对象，$(C !is) 运算符返回 $(C true)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Sometimes it makes sense to use a default value if a key does not exist in the associative array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T035616Z" creationid="Hipter" creationdate="20160709T035616Z">
        <seg>$(P
有时候在关联数组中，为不存在的键使用一个默认值是有道理的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Such control characters as well as all whitespace characters at both ends of strings can be removed by $(C std.string.strip):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T020538Z" creationid="Hipter" creationdate="20160712T020538Z">
        <seg>$(P
字符串两端的像空白符这样的控制字符能被 $(C std.string.strip) 移除：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
That function first modifies the reference parameter and then reverts this modification when an exception is thrown.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T022649Z" creationid="Hipter" creationdate="20160707T022649Z">
        <seg>$(P
上面这个函数首先修改引用参数，当出现异常时再恢复修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
That solution may be slow especially for large arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T141716Z" creationid="Hipter" creationdate="20160711T012152Z">
        <seg>$(P
对于大型数组这恐怕会非常慢。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C dayNumbers) variable above is an associative array that can be used as a table that provides a mapping from day names to day numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T030402Z" creationid="Hipter" creationdate="20160708T141034Z">
        <seg>$(P
上面的 $(C dayNumbers) 变量是一个关联数组，它能用来作为从日期名映射到日期数字的表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C dup()) member function makes a new object by taking advantage of the constructor of $(C Foo) and returns the new object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T023149Z" creationid="Hipter" creationdate="20160706T023149Z">
        <seg>$(P
$(C dup())  成员函数利用 $(C Foo) 的构造函数，创建并返回新的对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C in) operator determines whether a given key exists in the associative array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T035220Z" creationid="Hipter" creationdate="20160709T035220Z">
        <seg>$(P
$(C in) 运算符确定一个给定的键是否存在于关联数组中：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C new) keyword constructs an anonymous class object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T011520Z" creationid="Hipter" creationdate="20160706T011520Z">
        <seg>$(P
 $(C new) 关键字构造了一个匿名的类对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C scope(failure)) statement above ensures that the $(C r -= addend) expression will be executed if the function's scope is exited due to an exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T033858Z" creationid="Hipter" creationdate="20160707T033858Z">
        <seg>$(P
上面的 $(C scope(failure)) 确保 $(C r -= addend) 表达式在因异常退出时被执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C scope) statements have similar functionality with the $(C catch) and $(C finally) scopes but they are better in many respects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T024746Z" creationid="Hipter" creationdate="20160707T024746Z">
        <seg>$(P
$(C scope) 语句与 $(C catch) 和 $(C finally) 有相似功能，但在许多方面表现的更好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C strip()) expression above returns a new string that does not contain the trailing control characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T021126Z" creationid="Hipter" creationdate="20160712T020830Z">
        <seg>$(P
上面的 $(C strip()) 表达式返回一个不包含尾随控制符的新字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The Enter key that the user presses after the name does not terminate the input.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T004459Z" creationid="Hipter" creationdate="20160712T004052Z">
        <seg>$(P
用户在名字之后按的 Enter 键并没有结束输入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The assignment above makes $(C variable1) leave its object and start providing access to $(C variable2)'s object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T031250Z" creationid="Hipter" creationdate="20160706T031250Z">
        <seg>$(P
上面的赋值让 $(C variable1) 离开其对象并且开始提供对 $(C variable2) 的对象的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The behavior of assignment cannot be changed for classes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T031647Z" creationid="Hipter" creationdate="20160706T031647Z">
        <seg>$(P
赋值操作不能改变类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The exclamation mark appears after those characters instead of being printed right after the name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T015039Z" creationid="Hipter" creationdate="20160712T015039Z">
        <seg>$(P
感叹号出现在了那些字符之后，而不是打印在名字右侧。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The fact that plain arrays provide access to their values through index numbers can be described as an $(I association) of indexes with values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T023126Z" creationid="Hipter" creationdate="20160708T084434Z">
        <seg>$(P
事实上简单数组通过索引访问值可以被描述为索引与值的$(I 关联) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The first line above removes the key-value pair "Tuesday" / $(C 1).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160709T032313Z">
        <seg>$(P
上面第一行移除了键值对 "Tuesday" / $(C 1).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The following code makes use of $(C dup()) to create a new object:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T023705Z" creationid="Hipter" creationdate="20160706T023705Z">
        <seg>$(P
下面的代码演示 $(C dup()) 创建一个新的对象的用法：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The grades can also be assigned in one go with an array literal:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T022153Z" creationid="Hipter" creationdate="20160711T022153Z">
        <seg>$(P
成绩也可以作为数组文本一次性赋值：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The high performance of hash tables comes at the expense of storing the elements in an unordered way.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T131431Z" creationid="Hipter" creationdate="20160708T092120Z">
        <seg>$(P
hash 表的高性能的代价是元素的存储是无序的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The keys of associative arrays can be of any type, including user-defined $(C struct) and $(C class) types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T142042Z" creationid="Hipter" creationdate="20160708T141705Z">
        <seg>$(P
关联数组的键可以是任何类型，包括用户定义的 $(C struct) 和 $(C class) 类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The length of associative arrays cannot be specified when defined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T142139Z" creationid="Hipter" creationdate="20160708T142139Z">
        <seg>$(P
定义时，不能指定关联数组的长度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The name of a specific day can be accessed by its index in that array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T235015Z" creationid="Hipter" creationdate="20160708T084239Z">
        <seg>$(P
在数组里通过索引访问特定的英文日期名：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output indicates that the values 0 and 1 correspond to keys "Monday" and "Tuesday", respectively:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T091105Z" creationid="Hipter" creationdate="20160709T024828Z">
        <seg>$(P
下面的输出表明了元素值 0 和 1 分别对应着键 “Monday” 和 “Tuesday”：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The program can now be compiled and will print the modified string:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T025856Z" creationid="Hipter" creationdate="20160713T025856Z">
        <seg>$(P
现在程序能通过编译并且打印修改后的字符串：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The solution here is to take a copy of the immutable string by using the $(C .dup) property:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T025651Z" creationid="Hipter" creationdate="20160713T025651Z">
        <seg>$(P
这儿的解决办法是通过 $(C .dup) property（属性）得到一个不可变字符串的副本：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The syntax of associative arrays is similar to the array syntax.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T094902Z" creationid="Hipter" creationdate="20160708T094902Z">
        <seg>$(P
关联数组的语法与数组相似。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The table grows automatically with each association.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T132057Z" creationid="Hipter" creationdate="20160708T145054Z">
        <seg>$(P
随着每次的关联，该表会自动增长。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There are surprises even when reading strings from the terminal.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T094459Z" creationid="Hipter" creationdate="20160711T092623Z">
        <seg>$(P
从终端读字符串您会有一些惊奇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There are three $(I aliases) of the $(I immutable) versions of those types: $(C string), $(C wstring), and $(C dstring).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T081640Z" creationid="Hipter" creationdate="20160712T081640Z">
        <seg>$(P
这些类型的 $(I immutable) 版本有三个$(I 别名)：$(C string)，$(C wstring)，和 $(C dstring)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There are three string types that correspond to the three character types: $(C char[]), $(C wchar[]), and $(C dchar[]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T080510Z" creationid="Hipter" creationdate="20160712T080418Z">
        <seg>$(P
三种字符串类型对应着三种字符类型：$(C char[])，$(C wchar[])，和 $(C dchar[])。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There can be only one value per key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T132156Z" creationid="Hipter" creationdate="20160709T025550Z">
        <seg>$(P
每个键有且仅有一个对应值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
These operators operate on class variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T013802Z" creationid="Hipter" creationdate="20160707T013802Z">
        <seg>$(P
这些运算符应用在类变量上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This simple definition may be misleading.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T091239Z" creationid="Hipter" creationdate="20160711T091239Z">
        <seg>$(P
这个简单的定义可能是个误导。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This time the compilation error is due to the combination of two factors:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T023816Z" creationid="Hipter" creationdate="20160713T023816Z">
        <seg>$(P
这次的编译错误是因为两个因素碰了头：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Unlike structs, there is no automatic object construction where the constructor parameters are assigned to members sequentially:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T032818Z" creationid="Hipter" creationdate="20160706T032818Z">
        <seg>$(P
不像结构，构造函数参数按顺序分配给成员时，类没有自动构造对象：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Using the assignment operator is sufficient to build the association between a key and a value:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T144951Z" creationid="Hipter" creationdate="20160708T144951Z">
        <seg>$(P
使用赋值运算符就足以构建键与值的关联：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We can make the following observations about the use of these blocks:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T022106Z" creationid="Hipter" creationdate="20160707T022106Z">
        <seg>$(P
对于这些块的用法，我们可以作以下观测：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We have seen that single quotes are used to define character literals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T005300Z" creationid="Hipter" creationdate="20160712T075903Z">
        <seg>$(P
我们已经看到单引号用于定义字符字面量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We have used strings in many programs that we have seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T090616Z" creationid="Hipter" creationdate="20160711T090616Z">
        <seg>$(P
迄今为至，我们已经看到，好多程序都用到了字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We may think of defining the variable as a $(C char[]) instead of the $(C string) alias but that cannot be compiled either:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T023409Z" creationid="Hipter" creationdate="20160713T023409Z">
        <seg>$(P
我们可能想到把变量定义为 $(C char[]) 而不是别名 $(C string)，但也不能通过编译：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We saw in the $(LINK2 /ders/d.en/arrays.html, Arrays chapter) that plain arrays are containers that store their elements side-by-side and provide access to them by index.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T151814Z" creationid="Hipter" creationdate="20160708T081001Z">
        <seg>$(P
在 $(LINK2 /ders/d.cn/arrays.html, 数组) 一章中我们已经看到简单数组作为容器逐个存储元素，按索引访问它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When the actual object needs to be copied, the class must have a member function for that purpose.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T022112Z" creationid="Hipter" creationdate="20160706T021806Z">
        <seg>$(P
当需要复制实际的对象时，类必须有一个针对此目的的成员函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When the input cannot be converted to $(C name) and $(C age), the program prints an error:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T075238Z" creationid="Hipter" creationdate="20160712T075010Z">
        <seg>$(P
当输入不能转换到 $(C name) 和 $(C age) 时，程序打印一个错误：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When the type of $(C s) is $(C char[]), the type of the expression on the right-hand side of the assignment above is $(C char[]) as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T032929Z" creationid="Hipter" creationdate="20160713T032929Z">
        <seg>$(P
当 $(C s) 的类型是 $(C char[])，上面右手侧赋值的表达式类型也是 $(C char[]) ，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When the variables provide access to the same object, $(C is) returns $(C true):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015456Z" creationid="Hipter" creationdate="20160707T015456Z">
        <seg>$(P
当变量提供对同一对象的访问时，$(C is) 返回 $(C true)：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
上面这个函数首先修改引用参数，当出现异常时再恢复修改。不幸的是，$(C addend) 只能在定义它的 $(C try) 块里访问。$(I ($(B 注：) 这与命名作用域，以及对象生存期有关，这将在 $(LINK2 /ders/d.cn/lifetimes.html, 后面的章节) 中解释。))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T021046Z" creationid="Hipter" creationdate="20160708T021046Z">
        <seg>$(P
上面这个函数首先修改引用参数，当出现异常时再恢复修改。不幸的是，$(C addend) 只能在定义它的 $(C try) 块里访问。$(I ($(B 注：) 这与命名作用域，以及对象生存期有关，这将在 $(LINK2 /ders/d.cn/lifetimes.html, 后面的一章) 中解释。))
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
与结构不同的是一些成员函数自动继承自 $(C Object) 类。在 $(LINK2 /ders/d.cn/inheritance.html, 下一章节) 我们将看到怎样通过$(C override) 关键字来修改 $(C toString) 的定义。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T020733Z" creationid="Hipter" creationdate="20160708T020733Z">
        <seg>$(P
与结构不同的是一些成员函数自动继承自 $(C Object) 类。在 $(LINK2 /ders/d.cn/inheritance.html, 下一章) 中我们将看到怎样通过$(C override) 关键字来修改 $(C toString) 的定义。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
与结构的最大区别是结构是 $(I 值类型) 类是 $(I 引用类型)。下面的其它不同大部分与此有关。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T035217Z" creationid="Hipter" creationdate="20160708T035045Z">
        <seg>$(P
与结构的最大区别是结构是 $(I 值类型) 而类是 $(I 引用类型)。下面的其它不同大部分与此有关。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
例如，让我们用 $(C scope(failure)) 语句写一下面的函数：
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T034510Z" creationid="Hipter" creationdate="20160708T034510Z">
        <seg>$(P
例如，让我们用 $(C scope(failure)) 语句写一下下面的函数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
像结构一样，析构函数的名称是 $(C ~this):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T104213Z" creationid="Hipter" creationdate="20160707T104213Z">
        <seg>$(P
像结构一样，析构函数的名称是 $(C ~this)：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
原因是， $(C ==) 运算符会查询对象成员的值，并尝试通过一个潜在的 $(C null) 变量访问成员，这将引发一个内存访问错误。因此，类变量必须总是通过 $(C is) 和 $(C !is) 运算符做比较。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T104345Z" creationid="Hipter" creationdate="20160707T104345Z">
        <seg>$(P
原因是 $(C ==) 运算符会查询对象成员的值，并尝试通过一个潜在的 $(C null) 变量访问成员，这将引发一个内存访问错误。因此，类变量必须总是通过 $(C is) 和 $(C !is) 运算符做比较。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
另一方面，类变量是用于访问类对象的一种语言特性。虽然语法上看起来是在类 $(I 变量) 上执行，但实际上调度了一个类 $(I object)。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T035630Z" creationid="Hipter" creationdate="20160708T035630Z">
        <seg>$(P
另一方面，类变量是用于访问类对象的一种语言特性。虽然语法上看起来是在类 $(I 变量) 上执行，但实际上调度了一个类 $(I 对象)。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
在 $(LINK2 /ders/d.cn/null_is.html, The $(CH4 null) 值和 $(CH4 is) 运算符章节)， 本书已简要的提到，类变量可以是 $(C null)。换句话说，类变量可以不提供对任何对象的访问。类变量没有值本身；实际的类对象必须由 $(C new) 关键字构造。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T020020Z" creationid="Hipter" creationdate="20160708T020020Z">
        <seg>$(P
在 $(LINK2 /ders/d.cn/null_is.html, $(CH4 null) 值和 $(CH4 is) 运算符一章) 中， 本书已简要的提到，类变量可以是 $(C null)。换句话说，类变量可以不提供对任何对象的访问。类变量没有值本身；实际的类对象必须由 $(C new) 关键字构造。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
在上面的代码中， $(C variable2) 由 $(C variable1) 初始化。这俩变量可访问同一对象。The two variables start providing access to the same object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T104919Z" creationid="Hipter" creationdate="20160707T104919Z">
        <seg>$(P
在上面的代码中， $(C variable2) 由 $(C variable1) 初始化。这俩变量可访问同一对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
封装是通过 $(I 保护属性) 来实现， 在 $(LINK2 /ders/d.cn/encapsulation.html, 稍后的章节) 将会看到。继承是用于获取其它类型的 $(I 实现) 。$(LINK2 /ders/d.cn/inheritance.html, 多态性) 是从类之间抽象出部分代码，通过 $(I 接口) 来实现。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T034923Z" creationid="Hipter" creationdate="20160708T015803Z">
        <seg>$(P
封装是通过 $(I 保护属性) 来实现， 在 $(LINK2 /ders/d.cn/encapsulation.html, 稍后的一章) 中将会看到。继承是用于获取其它类型的 $(I 实现) 。$(LINK2 /ders/d.cn/inheritance.html, 多态性) 是从类之间抽象出部分代码，通过 $(I 接口) 来实现。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
当需要复制实际的对象时，类必须有一个针对此目的的成员函数。为与数组兼容，该函数可以命名为 $(C dup()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T103944Z" creationid="Hipter" creationdate="20160707T103944Z">
        <seg>$(P
当需要复制实际的对象时，类必须有一个针对此目的的成员函数。为与数组兼容，该函数可以命名为 $(C dup())。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
我们将在后面看到 $(LINK2 /ders/d.cn/memory.html, 内存管理章节)，类的析构函数必须遵守以下规则：
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T020446Z" creationid="Hipter" creationdate="20160708T020446Z">
        <seg>$(P
我们将在后面 $(LINK2 /ders/d.cn/memory.html, 内存管理一章) 中看到，类的析构函数必须遵守以下规则：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
由于 $(C myKing) 和 $(C yourKing) 变量来自不同的对象，$(C !is) 运算符返回 $(C true)。即使这两个对象由同一字符 $(C'♔')  参数构造，, 它们仍是两个单独的对象。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T041227Z" creationid="Hipter" creationdate="20160708T041227Z">
        <seg>$(P
由于 $(C myKing) 和 $(C yourKing) 变量来自不同的对象，$(C !is) 运算符返回 $(C true)。即使这两个对象由同一字符 $(C'♔')  参数构造， 它们仍是两个单独的对象。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
虽然成员函数的定义与用法与结构相同，有个重要的不同：类成员函数默认是 $(I 可重写的) 。在 $(LINK2 /ders/d.cn/inheritance.html,继承章节) 我们将看到相关内容。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T020547Z" creationid="Hipter" creationdate="20160708T020547Z">
        <seg>$(P
虽然成员函数的定义与用法与结构相同，有个重要的不同：类成员函数默认是 $(I 可重写的) 。在 $(LINK2 /ders/d.cn/inheritance.html,继承一章) 中我们将看到相关内容。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
让我们考虑一下下面我们以前在 $(LINK2 /ders/d.cn/value_vs_reference.html, 值类型和引用类型章节) 看到过的代码：
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T020154Z" creationid="Hipter" creationdate="20160708T020154Z">
        <seg>$(P
让我们考虑一下下面的我们以前在 $(LINK2 /ders/d.cn/value_vs_reference.html, 值类型和引用类型一章) 中看到过的代码：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(PROBLEM
How can all of the key-value pairs of an associative array be removed other than calling $(C .clear)?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T094612Z" creationid="Hipter" creationdate="20160709T083844Z">
        <seg>$(PROBLEM
除 $(C .clear) 函数外还有什么方法能移除关联数组的全部键值对？ </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(PROBLEM
Just like with arrays, there can be only one value for each key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T085009Z" creationid="Hipter" creationdate="20160709T085009Z">
        <seg>$(PROBLEM
与数组一样，每个键有且仅有一个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE (Let's assume that Enter is pressed a second time here))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T004651Z" creationid="Hipter" creationdate="20160712T004651Z">
        <seg>$(SHELL_NOTE (让我们假设在这儿第二次按了Enter键))
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE The input is not terminated although Enter has been pressed)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T004632Z" creationid="Hipter" creationdate="20160712T004632Z">
        <seg>$(SHELL_NOTE 虽然按了Enter键，但输入没有中断)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE no new-line character)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T021122Z" creationid="Hipter" creationdate="20160712T021122Z">
        <seg>$(SHELL_NOTE 没有新行符)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE_WRONG (one more before the exclamation mark))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T014858Z" creationid="Hipter" creationdate="20160712T014834Z">
        <seg>$(SHELL_NOTE_WRONG (在感叹号前还有一个))
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE_WRONG new-line character after the name)
!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T014717Z" creationid="Hipter" creationdate="20160712T014717Z">
        <seg>$(SHELL_NOTE_WRONG 名字之后的新行符)
!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE_WRONG new-line character before the exclamation mark)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T020346Z" creationid="Hipter" creationdate="20160712T020346Z">
        <seg>$(SHELL_NOTE_WRONG 感叹号前有新行符)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(STRING 'a') is a character; $(STRING "a") is a string that contains a single character.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T080044Z" creationid="Hipter" creationdate="20160712T080044Z">
        <seg>$(STRING 'a') 是一个字符；$(STRING "a") 是一个包含单字符的字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(UL
$(LI $(C scope(exit)): the expression is always executed when exiting the scope, regardless of whether successfully or due to an exception)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T025349Z" creationid="Hipter" creationdate="20160707T025349Z">
        <seg>$(UL
$(LI $(C scope(exit))：表达式总是在退出作用域时被执行， 无论是否成功或出现异常。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($(C .clear) is the most natural method.) There are at least three methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T094657Z" creationid="Hipter" creationdate="20160709T084034Z">
        <seg>($(C .clear) 是最自然的方法。) 至少还有三种方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(We will see D's $(I immutability) concept in later chapters.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T082209Z" creationid="Hipter" creationdate="20160712T082117Z">
        <seg>(在稍后的章节我们将看到 D的$(I 不可变性) 概念。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(anonymous MyClass object)    variable1    variable2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T011847Z" creationid="Hipter" creationdate="20160706T011847Z">
        <seg>(匿名的 MyClass 对象)    variable1    variable2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>)
$(LI The $(C char[]) on the left-hand side is a slice, which, if the code compiled, would provide access to all of the characters of the right-hand side.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T024512Z" creationid="Hipter" creationdate="20160713T024324Z">
        <seg>)
$(LI 左手侧的 $(C char[]) 是一个切片，代码编译时，它会访问右手侧的全部字符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* associative array is being defined with an extra</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T122913Z" creationid="Hipter" creationdate="20160711T020244Z">
        <seg>*关联数组在定义时附加了额外的空格，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* see the 'foreach' loop in the next chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T011359Z" creationid="Hipter" creationdate="20160711T011324Z">
        <seg>*看到‘foreach’循环。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* space in between to help distinguish the value type: */</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T122942Z" creationid="Hipter" creationdate="20160711T020350Z">
        <seg>* 以易于区分值类型： */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* the value type is int[], i.e. an array of ints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T120729Z" creationid="Hipter" creationdate="20160711T014929Z">
        <seg>* 值类型为 int[] ，即整型数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* used for appending the new grade to that array: */</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T021222Z" creationid="Hipter" creationdate="20160711T021222Z">
        <seg>* 将用于附加新成绩：*/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* 'foreach' is similar but superior to 'for'.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T115742Z" creationid="Hipter" creationdate="20160711T011155Z">
        <seg>/* ‘foreach’类似于‘for’，但比它更有优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Printing the grades of "emre": */</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T021258Z" creationid="Hipter" creationdate="20160711T021258Z">
        <seg>/* 打印“emre”的成绩： */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* The array of ints that correspond to "emre" is being</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T021215Z" creationid="Hipter" creationdate="20160711T021215Z">
        <seg>/* 与“emre” 对应的整型数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* The key type of this associative array is string and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T120710Z" creationid="Hipter" creationdate="20160711T014817Z">
        <seg>/* 该关联数组的键类型为 string，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// associates value 0 with key "Monday"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T090946Z" creationid="Hipter" creationdate="20160708T145014Z">
        <seg>// 关联值 0 与 键 “Monday”</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// associates value 1 with key "Tuesday"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T090956Z" creationid="Hipter" creationdate="20160708T145024Z">
        <seg>// 关联值 1 与 键 “Tuesday”</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// key "purple" does not exist in the table</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T132616Z" creationid="Hipter" creationdate="20160709T035323Z">
        <seg>//表中不存在 键 “purple” </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// key "purple" exists in the table</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T091115Z" creationid="Hipter" creationdate="20160709T035300Z">
        <seg>// 键 “purple” 在表中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A benefit of $(C scope(failure)) is the fact that the expression that reverts another expression is written close to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T034926Z" creationid="Hipter" creationdate="20160707T034511Z">
        <seg>$(C scope(failure)) 的好处是靠近它的表达式可以还原已写的另一个表达式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, unlike arrays, the elements of hash tables are not stored side-by-side.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T131420Z" creationid="Hipter" creationdate="20160708T092324Z">
        <seg>不像数组，hash 表的元素不是逐个排列存储的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although it may seem syntactically that operations are being performed on a class $(I variable), the operations are actually dispatched to a class $(I object).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T010501Z" creationid="Hipter" creationdate="20160706T010501Z">
        <seg>虽然语法上看起来是在类 $(I 变量) 上执行，但实际上调度了一个类 $(I object)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although this difference makes associative arrays use more memory, it also allows them to use $(I sparse) key values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T233339Z" creationid="Hipter" creationdate="20160708T093947Z">
        <seg>虽然这种不同让关联数组使用更多内存，但它也允许它们使用$(I 稀疏)键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array that stores the names of the days of the week can be defined like this:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T232810Z" creationid="Hipter" creationdate="20160708T083910Z">
        <seg>一个存储了星期的英文名称的数组可以这样定义：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays of these character types lead to three separate string types, some of which may have surprising outcomes in some string operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T092039Z" creationid="Hipter" creationdate="20160711T092039Z">
        <seg>这些字符类型的数组导致三种独立的字符串类型， 其中一些可能会在一些字符串操作上有出人意料的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As we have seen in the $(LINK2 /ders/d.en/characters.html, Characters chapter), D has three separate character types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T091729Z" creationid="Hipter" creationdate="20160711T091315Z">
        <seg>正如我们在 $(LINK2 /ders/d.cn/characters.html, 字符一章) 中看到的， D具有三种独立的字符类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning that return value back to $(C name) produces the intended output:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T021109Z" creationid="Hipter" creationdate="20160712T021109Z">
        <seg>返回值再赋值给 $(C name)，得到预期的输出：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associative arrays are initialized similarly to regular arrays, using a colon to separate each key from its respective value:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T024011Z" creationid="Hipter" creationdate="20160709T031925Z">
        <seg>关联数组的初始化与常规数组相似，不同的是用冒号分隔每个键与相应的值：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associative arrays store their elements as key-value pairs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160708T090211Z">
        <seg>关联数组通过键值对存储它们的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because array elements are stored side-by-side in memory, index values are implicitly the relative positions of elements from the beginning of the array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T093155Z" creationid="Hipter" creationdate="20160708T093357Z">
        <seg>因为在内存中数组元素是逐个存储的，索引值就是元素位置与数组的起始位置的相对值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Being value types, $(C o) and $(C i) are copied automatically.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T023459Z" creationid="Hipter" creationdate="20160706T023459Z">
        <seg>做为值类型，$(C o) 和 $(C i) 自动被复制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chaining the result of $(C readln()) to $(C strip()) enables a shorter and more readable syntax:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T021719Z" creationid="Hipter" creationdate="20160712T021719Z">
        <seg>链接 $(C readln()) 的结果到 $(C strip())，能得到更短且可读性更好的语法：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking against $(C null) must be done by $(C is) or $(C !is), not by $(C ==) or $(C !=).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020106Z" creationid="Hipter" creationdate="20160707T020106Z">
        <seg>检查 $(C null) 必须使用 $(C is) 或 $(C !is)，而不是 $(C ==) 或 $(C !=)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class variables do not have members, the class objects do.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T004327Z" creationid="Hipter" creationdate="20160707T004327Z">
        <seg>类变量没有成员，类对象有。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=Programming in D exercise solutions: Associative Arrays</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T022345Z" creationid="Hipter" creationdate="20160711T022345Z">
        <seg>DESCRIPTION=D语言习题解答：关联数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=Programming in D exercise solutions: strings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T095637Z" creationid="大处着手小处着眼" creationdate="20160714T095637Z">
        <seg>DESCRIPTION=D语言编程习题解答：字符串</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=The associative arrays of the d programming language.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092656Z" creationid="Hipter" creationdate="20160709T092656Z">
        <seg>DESCRIPTION=D语言的关联数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=The basic object oriented programming (OOP) feature of the D programming language.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020838Z" creationid="Hipter" creationdate="20160707T020838Z">
        <seg>DESCRIPTION=D语言基本的面向对象编程 (OOP) 功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=The scope(success), scope(failure), and scope(exit) statements that are used for specifying expressions that must be executed when exiting scopes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T045751Z" creationid="Hipter" creationdate="20160707T045751Z">
        <seg>DESCRIPTION=scope(success)，scope(failure)，和 scope(exit) 语句用于当退出作用域时一定要执行的特殊表达式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define an associative array that can store multiple grades per student.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092617Z" creationid="Hipter" creationdate="20160709T092617Z">
        <seg>定义一个能存储每个学生的多个成绩的关联数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though the two objects are constructed by the same character $(C'♔'), they are still two separate objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015411Z" creationid="Hipter" creationdate="20160707T015411Z">
        <seg>即使这两个对象由同一字符 $(C'♔')  参数构造，, 它们仍是两个单独的对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Executing the $(C scope) statements in reverse order enables undoing side effects of earlier expressions in a consistent order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T045550Z" creationid="Hipter" creationdate="20160707T045428Z">
        <seg>这样按相反顺序执行 $(C scope) 语句，让程序能按一致的顺序撤消前边表达式的副作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For classes, the meaning of $(C opAssign) is always $(I associating a class variable with a class object).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T005153Z" creationid="Hipter" creationdate="20160707T005153Z">
        <seg>对于类， $(C opAssign) 意味着 $(I 一个类变量总是关联着一个类对象)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, $(C char[]) is a type of string.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T091203Z" creationid="Hipter" creationdate="20160711T091203Z">
        <seg>例如，$(C char[]) 字符串类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, $(C dayNumbers) would have two key-value pairs after the operations above.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160708T145157Z">
        <seg>例如，上面的操作结束后 $(C dayNumbers) 将有两个键值对。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, as the $(C formattedRead()) call above expects to read $(I two) items (a $(C string) as name and an $(C int) as age), the following check ensures that it really is the case:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T075053Z" creationid="Hipter" creationdate="20160712T074138Z">
        <seg>例如，像上面的 $(C formattedRead()) 函数期望去读$(I 两个)项目(一个 $(C string) 型 name 和一个 $(C int) 型 age)，下面的检查确定它真是这样：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if $(C s) is a variable of type $(C char[]), the following line will fail to compile:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T032200Z" creationid="Hipter" creationdate="20160713T030425Z">
        <seg>例如，如果 $(C s) 的变量类型是 $(C char[])，下面这行将编译失败：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, let's assume that the grades 90, 85, 95, etc. are to be stored for the student named "emre".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T233623Z" creationid="Hipter" creationdate="20160709T090853Z">
        <seg>例如，我们假设存储学生“emre”的成绩 90，85，95 等等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the characters of a $(C wchar[]) can be modified but the characters of a $(C wstring) cannot be modified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T081951Z" creationid="Hipter" creationdate="20160712T081951Z">
        <seg>例如，可以修改一个 $(C wchar[]) ，但不可修改一个 $(C wstring) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the special value of -1 can be used as the code for colors that are not in $(C colorCodes).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T035915Z" creationid="Hipter" creationdate="20160709T035915Z">
        <seg>例如，特殊值 -1 用作不在 $(C colorCodes) 中的  colors 代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, when there are just two elements to store for keys 0 and 999, an associative array stores just two elements, not 1000 as a plain array has to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T233433Z" creationid="Hipter" creationdate="20160708T094744Z">
        <seg>例如，对于键 0 和 999，当只有两个元素要存储时，关联数组就只存储两个元素，而不像简单数组那样必须 1000 个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that reason, when we assign a new key-value pair and the key already exists, the table does not grow; instead, the value of the existing key changes:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T132325Z" creationid="Hipter" creationdate="20160709T030446Z">
        <seg>因而，给一个存在的键赋值，表不增长，而现有键所对应的值会发生变化：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For these reasons, $(C readf()) does not work as intended when reading strings:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T095603Z" creationid="Hipter" creationdate="20160711T095603Z">
        <seg>因而，$(C readf()) 不能如愿读取字符串：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further, because there is no way to tell $(C readf()) how many characters to read, it continues to read until the end of the entire input.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T003853Z" creationid="Hipter" creationdate="20160711T095339Z">
        <seg>另外，因为没有办法告诉 $(C readf()) 要读取多少字符， 它持续读，直到整个输入结束。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash tables are among the fastest collections for storing and accessing elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T091320Z" creationid="Hipter" creationdate="20160708T091320Z">
        <seg>Hash 表是存储和访问元素的最快的集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the grades cannot be inserted as in the following code because each grade would overwrite the previous one:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T233816Z" creationid="Hipter" creationdate="20160709T092351Z">
        <seg>然而，不能像下面的代码这样插入成绩，因为后来的成绩将覆盖前一个：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the user eventually terminates the input that way, we see that the new-line characters have been read as parts of the string as well:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T014616Z" creationid="Hipter" creationdate="20160712T014616Z">
        <seg>如果用户最后这样结束输入，我们看到新行符已作为字符串的一部分被读取：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to copy class objects, the type must have a special function likely named $(C dup()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020430Z" creationid="Hipter" creationdate="20160707T020335Z">
        <seg>为了复制类对象，类型必须有一个类似于命名为 $(C dup()) 的特殊函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, $(C opAssign) cannot be overloaded for them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T031807Z" creationid="Hipter" creationdate="20160706T031807Z">
        <seg>换句话说，$(C opAssign) 不能因为它们而被重载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, arrays map indexes to values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T084530Z" creationid="Hipter" creationdate="20160708T084530Z">
        <seg>换句话说，数组映射索引到值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, it can be used as the opposite of the $(C dayNames) array at the beginning of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T030433Z" creationid="Hipter" creationdate="20160708T141319Z">
        <seg>换句话说，它能用作本章开始处 $(C dayNames) 数组的逆转。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such cases, the $(C .idup) property can be used to produce an immutable $(C string) variable from a mutable $(C char[]) variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T030418Z" creationid="Hipter" creationdate="20160713T030418Z">
        <seg>这种情况下，$(C .idup) property 能被用来从一个可变的 $(C char[]) 变量产生一个不可变的 $(C string) 变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case it $(I returns) the line that it has just read.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T021527Z" creationid="Hipter" creationdate="20160712T021418Z">
        <seg>在这种情况下它$(I 返回)刚刚读入的行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the simplest definition, strings are nothing but arrays of characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T091131Z" creationid="Hipter" creationdate="20160711T091131Z">
        <seg>在最简单的定义中，字符串只不过是字符数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is used differently because the $(STRING " %s") format string and the $(C &amp;) operator are not needed:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T015633Z" creationid="Hipter" creationdate="20160712T015506Z">
        <seg>不同的是没有 $(STRING " %s") 格式字符串并且不需要 $(C &amp;) 运算符：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns $(C true) if the object is the same and $(C false) otherwise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T014719Z" creationid="Hipter" creationdate="20160707T014719Z">
        <seg>如果是同一对象，返回 $(C true) ，否则为 $(C false) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterating over this slice and removing the element for each key by calling $(C .remove) would result in an empty associative array:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T010819Z" creationid="Hipter" creationdate="20160711T005658Z">
        <seg>迭代这个切片，通过为每个键调用 $(C .remove) 函数来移除元素，就会形成一个空的关联数组：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its first parameter is the line that contains the data, and the rest of the parameters are used exacly like $(C readf()):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T033508Z" creationid="Hipter" creationdate="20160712T033324Z">
        <seg>它的第一个参数是包含数据的行，剩余的参数可以像 $(C readf()) 那样精确使用：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming language tutorial book associative arrays</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092726Z" creationid="Hipter" creationdate="20160709T092726Z">
        <seg>KEYWORDS=D 编程语言教程 关联数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming language tutorial book scope</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T050130Z" creationid="Hipter" creationdate="20160707T045824Z">
        <seg>KEYWORDS=D 语言编程教程 scope</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming lesson book tutorial class</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T050241Z" creationid="Hipter" creationdate="20160707T020932Z">
        <seg>KEYWORDS=D 语言编程教程 class</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=programming in d tutorial associative arrays</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T022406Z" creationid="Hipter" creationdate="20160711T022406Z">
        <seg>KEYWORDS=D语言教程 关联数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's see this on a class that has various types of members:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T022751Z" creationid="Hipter" creationdate="20160706T022751Z">
        <seg>让我们在有各种类型成员的类上看看它：:
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like $(C finally), the three different $(C scope) statements are about executing expressions when leaving scopes:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T025251Z" creationid="Hipter" creationdate="20160707T025035Z">
        <seg>像 $(C finally)，下面三个不同的 $(C scope) 语句就是关于离开作用域时应执行的表达式：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the constructor copies the $(C s) member explicitly by the $(C .dup) property of arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T023408Z" creationid="Hipter" creationdate="20160706T023408Z">
        <seg>注意，构造函数通过数组的  $(C .dup) 属性显式复制 $(C s) 成员。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other than in rare pathological cases, the time it takes to store or access an element is independent of the number of elements that are in the associative array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T100056Z" creationid="Hipter" creationdate="20160708T091750Z">
        <seg>除极个别情况外，一般存取单个元素所花费的时间不依赖于关联数组中元素的个数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Plain arrays can use only integers as indexes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T085309Z" creationid="Hipter" creationdate="20160708T084606Z">
        <seg>简单数组只能使用整型做索引。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S      o;  // assume S is a struct type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T022841Z" creationid="Hipter" creationdate="20160706T022841Z">
        <seg>S      o;  // 假设 S 是一个结构类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Associative Arrays</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092636Z" creationid="Hipter" creationdate="20160709T092636Z">
        <seg>SUBTITLE=关联数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Associative Arrays Solutions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T041125Z" creationid="Hipter" creationdate="20160711T022321Z">
        <seg>SUBTITLE=关联数组 习题解答</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Classes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020705Z" creationid="Hipter" creationdate="20160707T020705Z">
        <seg>SUBTITLE=类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Strings Solution</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T095608Z" creationid="大处着手小处着眼" creationdate="20160714T095608Z">
        <seg>SUBTITLE=字符串 习题解答</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Short for "read line", $(C readln()) reads until the end of the line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T015218Z" creationid="Hipter" creationdate="20160712T015218Z">
        <seg>它是“read line”的缩写，$(C readln()) 读取到行尾。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since multiple grades can be stored in a dynamic array, an associative array that maps from $(C string) to $(C int[]) would work here.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T014352Z" creationid="Hipter" creationdate="20160711T014051Z">
        <seg>由于多个成绩可以用一个动态数组存储，从 $(C string) 到 $(C int[]) 映射的关联数组将能用在这儿。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since that key is not in the container anymore, the second line would cause an exception to be thrown and the program to be terminated if that exception is not caught.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T033921Z" creationid="Hipter" creationdate="20160709T033921Z">
        <seg>由于键已不存在于容器中， 因而第二行将引发一个异常，如果异常没有被捕获，程序将终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since there is no other variable for $(C variable1)'s original object, that object will be destroyed by the garbage collector.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T031538Z" creationid="Hipter" creationdate="20160706T031538Z">
        <seg>由于 $(C variable1) 的原始对象没有别的变量，该对象将由垃圾回收器销毁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String literals are defined with double quotes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T005323Z" creationid="Hipter" creationdate="20160712T075946Z">
        <seg>字符串字面量用双引号定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings are a combination of the two features that we have covered in the last three chapters: characters and arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T091043Z" creationid="Hipter" creationdate="20160711T091043Z">
        <seg>字符串是在过去三章中介绍的两种功能的组合：字符和数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That value can be compared against the expected number of data items so that the input can be validated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T074124Z" creationid="Hipter" creationdate="20160712T074124Z">
        <seg>该值可与数据项目的期望个数相比较，以便确定输入的有效性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T121050Z" creationid="Hipter" creationdate="20160711T120306Z">
        <seg>这个</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $(C king) variable does not have a $(C shape) member, the anonymous object does.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T004408Z" creationid="Hipter" creationdate="20160707T004408Z">
        <seg>$(C king) 变量并没有 $(C shape) 成员，匿名对象有。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $(C new) keyword constructs an anonymous $(I class object) and returns a $(I class variable).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015858Z" creationid="Hipter" creationdate="20160707T015858Z">
        <seg>The $(C new) 关键字构造一个匿名 $(I class 对象) 并返回一个 $(I class 变量)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual object is not copied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T012852Z" creationid="Hipter" creationdate="20160706T012821Z">
        <seg>实际的对象没有被复制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The characters of the variables that are defined by these aliases cannot be modified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T081806Z" creationid="Hipter" creationdate="20160712T081806Z">
        <seg>由这些别名定义的字符变量不可修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler does not allow accessing characters of an immutable array through a mutable slice.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T025135Z" creationid="Hipter" creationdate="20160713T025135Z">
        <seg>编译器不允许通过可变的切片访问不可变的字符数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default value is specified as the second parameter of $(C .get()):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T042602Z" creationid="Hipter" creationdate="20160709T042602Z">
        <seg>默认值被指定为 $(C .get()) 的第2个参数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The difference is that it is the type of the key that is specified within the square brackets, not the length of the array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T093513Z" creationid="Hipter" creationdate="20160708T095042Z">
        <seg>不同的是方框号中指定的是键的类型，而不是数组的长度：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following methods would empty the array in a single step.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T120214Z" creationid="Hipter" creationdate="20160711T012406Z">
        <seg>而下面的方法将用一步清空数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The grades can be appended to the dynamic arrays that are stored in the associative array:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T014729Z" creationid="Hipter" creationdate="20160711T014729Z">
        <seg>成绩能附加到存储在关联数组中的动态数组上：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two variables start providing access to the same object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T021711Z" creationid="Hipter" creationdate="20160706T021711Z">
        <seg>这俩变量可访问同一对象。The two variables start providing access to the same object.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values of the type that associative arrays $(I map from) are called $(I keys), rather than indexes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T023157Z" creationid="Hipter" creationdate="20160708T090042Z">
        <seg>关联数组用于$(I 映射)的类型的值叫$(I 键)，而不是索引。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are very fast data structures that work like mini databases and are used in many programs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T233259Z" creationid="Hipter" creationdate="20160708T015014Z">
        <seg>它们是高速的数据结构，如迷你数据库一样地运作，在很多程序里都用到了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They grow automatically as key-value pairs are added.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160708T143053Z">
        <seg>它们随着键值对的添加而自动增长。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They map the values of one type to the values of another type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T085824Z" creationid="Hipter" creationdate="20160708T085824Z">
        <seg>它们映射一种类型的值到另一种类型的值上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior cannot be changed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020610Z" creationid="Hipter" creationdate="20160707T020610Z">
        <seg>该行为不能被修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be demonstrated by printing the entire table:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T145930Z" creationid="Hipter" creationdate="20160708T145930Z">
        <seg>这可以通过打印整个表来验证：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This distinction has an important consequence when  $(LINK2 /ders/d.en/function_parameters.html, passing associative arrays to functions).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T144154Z" creationid="Hipter" creationdate="20160708T081001Z">
        <seg>当 $(LINK2 /ders/d.cn/function_parameters.html, 传关联数组给函数) 时，这种区分具有重要意义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function must create and return a new class object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T022554Z" creationid="Hipter" creationdate="20160706T022554Z">
        <seg>该函数必须创建并返回一个新的类对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because later code may depend on previous variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T045157Z" creationid="Hipter" creationdate="20160707T045157Z">
        <seg>这是因为后边的代码依赖于前边的变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is so that the program has a way of determining whether the input consisted of a complete line or whether the end of input has been reached:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T020302Z" creationid="Hipter" creationdate="20160712T020302Z">
        <seg>这就让程序有办法确定输入是否包含一条完整语句或者输入是否已结束： 
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may be seen as a limitation for some applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T085053Z" creationid="Hipter" creationdate="20160709T085053Z">
        <seg>对某些程序来说可能是个限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be compatible with arrays, this function may be named $(C dup()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T022458Z" creationid="Hipter" creationdate="20160706T022458Z">
        <seg>为与数组兼容，该函数可以命名为 $(C dup()).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, $(C addend) is accessible only in the $(C try) block, where it is defined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T022824Z" creationid="Hipter" creationdate="20160707T022824Z">
        <seg>不幸的是，$(C addend) 只能在定义它的 $(C try) 块里访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike structs, class objects cannot be constructed by the $(C {&amp;nbsp;}) syntax.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T032515Z" creationid="Hipter" creationdate="20160706T032515Z">
        <seg>不像结构，类对象不能由 $(C {&amp;nbsp;}) 语法构造。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T011230Z" creationid="Hipter" creationdate="20160711T011230Z">
        <seg>在下一章我们将</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will cover these concepts in later chapters.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T030254Z" creationid="Hipter" creationdate="20160708T144231Z">
        <seg>在稍后的章节中我们将涵盖这些概念。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see Phobos ranges in a later chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T094305Z" creationid="大处着手小处着眼" creationdate="20160714T094241Z">
        <seg>在稍后的一章中我们将看到 Phobos ranges 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see exceptions in $(LINK2 /ders/d.en/exceptions.html, a later chapter).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T034341Z" creationid="Hipter" creationdate="20160708T081001Z">
        <seg>在 $(LINK2 /ders/d.cn/exceptions.html, 稍后的一章) 中我们将看到异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see in $(LINK2 /ders/d.en/inheritance.html, the next chapter) how the definition of $(C toString) can be changed by the $(C override) keyword.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T013604Z" creationid="Hipter" creationdate="20160707T013604Z">
        <seg>在 $(LINK2 /ders/d.cn/inheritance.html, 下一章节) 我们将看到怎样通过$(C override) 关键字来修改 $(C toString) 的定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see this concept later in $(LINK2 /ders/d.en/inheritance.html, the Inheritance chapter).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T011019Z" creationid="Hipter" creationdate="20160707T005801Z">
        <seg>在 $(LINK2 /ders/d.cn/inheritance.html,继承章节) 我们将看到相关内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see user-defined types in later chapters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T141854Z" creationid="Hipter" creationdate="20160708T141751Z">
        <seg>在稍后的章节中我们将看到用户定义类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will use the $(C dayNumbers) associative array in the examples below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T141603Z" creationid="Hipter" creationdate="20160708T141603Z">
        <seg>在下面的例子中我们将使用 $(C dayNumbers) 关联数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When reading strings from the input, the control character that corresponds to the Enter key that is pressed at the end of the input becomes a part of the string as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T094720Z" creationid="Hipter" creationdate="20160711T092900Z">
        <seg>当从输入中读取字符串，输入结束时按的Enter键对应的控制字符将变成字符串的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When that exact syntax is desired, properties should be preferred, which will be explained in $(LINK2 /ders/d.en/property.html, a later chapter).)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T004716Z" creationid="Hipter" creationdate="20160707T004716Z">
        <seg>若确实需要这样的语法，应该首选属性，这将在 $(LINK2 /ders/d.cn/property.html, 后面的章节) 中解释。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can apply this guideline blindly unless there are compilation errors:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T051126Z" creationid="Hipter" creationdate="20160707T012523Z">
        <seg>若没有编译错误，您可以闭着眼睛按教程来：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may find especially the Phobos ranges confusing at this point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T094806Z" creationid="大处着手小处着眼" creationdate="20160714T094151Z">
        <seg>在这一点上，你会发现 Phobos 的让人迷惑的 ranges 尤其明显。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dayNumbers.clear;    // The associative array becomes empty
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T132349Z" creationid="Hipter" creationdate="20160709T034649Z">
        <seg>dayNumbers.clear;    // 清空关联数组
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>grades["emre"] = 85;   // ← Overwrites the previous grade!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092525Z" creationid="Hipter" creationdate="20160709T092525Z">
        <seg>grades["emre"] = 85;   // ← 覆盖前一个成绩！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>number = int.init;    // 0 for int
---
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T133427Z" creationid="Hipter" creationdate="20160709T084837Z">
        <seg>number = int.init;    // int 值：0 
---
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>string result = (s ~ '.')$(HILITE .idup);   // ← now compiles
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T160846Z" creationid="Hipter" creationdate="20160713T160846Z">
        <seg>string result = (s ~ '.')$(HILITE .idup);   // ← 现在可以编译
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>writeln(dayNames[1]);   // prints "Tuesday"
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T090929Z" creationid="Hipter" creationdate="20160708T084244Z">
        <seg>writeln(dayNames[1]);   // 打印 “Tuesday”
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>writeln(dayNumbers["Tuesday"]);    // prints 1
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T032006Z" creationid="Hipter" creationdate="20160709T032006Z">
        <seg>writeln(dayNumbers["Tuesday"]);    // 打印 1
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>writeln(dayNumbers["Tuesday"]);    // ← run-time ERROR
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T032204Z" creationid="Hipter" creationdate="20160709T032204Z">
        <seg>writeln(dayNumbers["Tuesday"]);    // ← 运行时错误
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>该函数必须创建并返回一个新的类对象。让我们在有各种类型成员的类上看看它：:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T104106Z" creationid="Hipter" creationdate="20160707T104106Z">
        <seg>该函数必须创建并返回一个新的类对象。让我们在有各种类型成员的类上看看它：
)</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
